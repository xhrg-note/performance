## 一 性能属性

* 吞吐量
  *  也就是在不考虑其他因素的QPS，TPS，增加吞吐量的代价是延迟增加，内存增加。甚至主机增加。
* 延迟和响应性
  *  eg。接口需要在60毫秒完成。 
  *  停顿时间暂停，避免应用程序抖动 
  *  缩小延迟的代价是更低的吞吐量，或者更多的内存消耗。
* 内存占用
  *  内存使用量
* 启动时间
  *  server还是client，比如说15秒内启动。 



## 二原则
* minor gc回收原则，MinorGC尽可能多得回收对象，避免FULLGC
* GC内存最大化原则，处理吞吐量和延迟问题时，Java堆越大，垃圾收集器效果越好，应用程序运行越流畅
* 吞吐量，延迟，内存占用，3选2.


## 调优方法和流畅
* 系统应用程序优先级，是否需要修改程序代码
* 选择jvm部署模式（1台还是多台。考虑因素有可用性，可管理性，内存使用）
* 选择jvm运行时包括垃圾收集器的选择
* 调优内存
* 调优延迟
* 调优吞吐量
* 完成

## 确定内存
* 确定活跃数据，也就是FUllGC后的Java堆大小
* 注意点，无论怎么样，都需要给操作系统预留一部分内存，至少1G。
* 可以把Xmx和Xms设置为一样(这两个参数是堆区的初始和最大)，因为这样可以避免堆的扩大和缩减，而扩大和缩进会造成FullGC，Fullgc会影响吞吐和延迟。持久带同理
* 第一步，避免OOM，哪里少了加哪里，减少OOM
* 然后确定活跃数据，活跃数据指的是，应用程序稳定后老年代和永久代的堆大小。通过多次fullgc后得数据得到，可以通过gc日志。gc有时间，推荐做法是用最差gc时间得那次数据作为估算值。
* 堆区的大小也就是xms和Xmx的值可以设置为老年代gc后大小的3-4倍(gc日志中得ParPdGen)。
* -XX:PermSize的值是永久代活跃数据的1.2到1.5倍
* 新生代空间应该为老年代活跃的1-1.5倍


空间 | 命令行 | 占用倍数
---|---|---
Java堆 | -Xms。-Xmx | 3-4倍FGC后老年代空间
永久代 | -XX:PermSize，-XX:MaxPermSize | 1.2-1.5倍FGC后永久代大小
新生代 | -Xmn | 1-1.5倍FGC后老年代空间
老年代 | 堆减去新生 | 2-3倍FGC后永久代大小




## 调优延迟和响应性

#### 结果
* 达到要求，继续调优吞吐量
* 达不到要求，修改程序，堆分析，减少对象分配，修改jvm部署，加机器，加jvm实例。

#### 评估标准
* Minor GC 的持续时间
* Minor Gc 的词素
* FGC的最差持续时间
* FGC的频率

> 对于延迟有要求的系统应该优先使用CMS收集器。

把系统的需求和GC时间对比，不满足则优化.


* 优化新生代
  * 新生代越小，gc次数越多，gc时间越短。如果发现gc持续时间大约应用程序的延迟性要求，则减少新生代空间大小。
  * 1 老年代空间不应该小于活跃数据1.5倍
  * 2 新生代空间至少是Java堆得10%
  * 3 增加堆大小，不应该超过jvm可用物理内存。

* 老年代优化 
  * 目标：避免STW的压缩GC

* cms优化
  *  
  
## 应用程序吞吐量


